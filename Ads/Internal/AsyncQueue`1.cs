// Decompiled with JetBrains decompiler
// Type: TwinCAT.Ads.Internal.AsyncQueue`1
// Assembly: TwinCAT.Ads, Version=6.0.164.0, Culture=neutral, PublicKeyToken=180016cd49e5e8c3
// MVID: E66A887E-650C-48BD-ACFF-80F7B9224E2B
// Assembly location: C:\projects\trimet_l1\contrib\beckhoff.twincat.ads\6.0.164\lib\net6.0\TwinCAT.Ads.dll
// XML documentation location: C:\projects\trimet_l1\contrib\beckhoff.twincat.ads\6.0.164\lib\net6.0\TwinCAT.Ads.xml

using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;


#nullable enable
namespace TwinCAT.Ads.Internal
{
  /// <summary>Class AsyncQueue.</summary>
  /// <typeparam name="T"></typeparam>
  public class AsyncQueue<T>
  {
    private ConcurrentQueue<T> _bufferQueue;
    private ConcurrentQueue<TaskCompletionSource<T>> _tcsQueue;
    private object _syncRoot = new object();

    /// <summary>
    /// Initializes a new instance of the <see cref="T:TwinCAT.Ads.Internal.AsyncQueue`1" /> class.
    /// </summary>
    public AsyncQueue()
    {
      this._bufferQueue = new ConcurrentQueue<T>();
      this._tcsQueue = new ConcurrentQueue<TaskCompletionSource<T>>();
    }

    /// <summary>Enqueues the specified item.</summary>
    /// <param name="item">The item.</param>
    public void Enqueue(T item)
    {
      TaskCompletionSource<T> result;
      while (!this._tcsQueue.TryDequeue(out result) || result.Task.IsCanceled || !result.TrySetResult(item))
      {
        if (result == null)
        {
          object syncRoot = this._syncRoot;
          bool lockTaken = false;
          try
          {
            Monitor.Enter(syncRoot, ref lockTaken);
            if (this._tcsQueue.TryDequeue(out result) && !result.Task.IsCanceled && result.TrySetResult(item))
              break;
            this._bufferQueue.Enqueue(item);
            break;
          }
          finally
          {
            if (lockTaken)
              Monitor.Exit(syncRoot);
          }
        }
      }
    }

    /// <summary>Dequeues the asynchronous.</summary>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns></returns>
    public Task<T> DequeueAsync(CancellationToken cancellationToken)
    {
      T result;
      if (!this._bufferQueue.TryDequeue(out result))
      {
        object syncRoot = this._syncRoot;
        bool lockTaken = false;
        try
        {
          Monitor.Enter(syncRoot, ref lockTaken);
          if (!this._bufferQueue.TryDequeue(out result))
          {
            TaskCompletionSource<T> promise = new TaskCompletionSource<T>();
            cancellationToken.Register((Action) (() => promise.TrySetCanceled()));
            this._tcsQueue.Enqueue(promise);
            this.OnPromiseAdded();
            return promise.Task;
          }
        }
        finally
        {
          if (lockTaken)
            Monitor.Exit(syncRoot);
        }
      }
      return Task.FromResult<T>(result);
    }

    /// <summary>
    /// Gets a value indicating whether this instance has promises.
    /// </summary>
    /// <value>
    /// <c>true</c> if this instance has promises; otherwise, <c>false</c>.
    /// </value>
    public bool HasPromises => this._tcsQueue.Where<TaskCompletionSource<T>>((Func<TaskCompletionSource<T>, bool>) (p => !p.Task.IsCanceled)).Any<TaskCompletionSource<T>>();

    /// <summary>
    /// Occurs when a new promise
    /// is generated by the queue
    /// </summary>
    public event EventHandler? PromiseAdded;

    /// <summary>Called when [promise added].</summary>
    protected virtual void OnPromiseAdded()
    {
      if (this.PromiseAdded == null)
        return;
      this.PromiseAdded((object) this, EventArgs.Empty);
    }
  }
}
